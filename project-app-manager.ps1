# Script PowerShell pour g√©rer l'application Projet-0
# Menu interactif num√©rot√© pour faciliter l'utilisation

$backendPath = "D:\project\windsurf\projet-0\backend"
$frontendPath = "D:\project\windsurf\projet-0\frontend"
$rootPath = "D:\project\windsurf\projet-0"
$backupPath = "D:\project\windsurf\projet-0\backups"
$backendPort = 3000
$frontendPort = 3001
$dbStudioPort = 5555

# Couleurs pour les messages
$Colors = @{
    Success = "Green"
    Error = "Red"
    Warning = "Yellow"
    Info = "Cyan"
    Primary = "Blue"
    Secondary = "Magenta"
    Muted = "Gray"
}

# Fonction pour afficher un message avec couleur et ic√¥ne
function Write-Message {
    param(
        [string]$Message,
        [string]$Type = "Info",
        [string]$Icon = ""
    )
    
    $color = $Colors[$Type]
    if ($Icon) {
        Write-Host "$Icon $Message" -ForegroundColor $color
    } else {
        Write-Host $Message -ForegroundColor $color
    }
}

# Fonction pour v√©rifier si un port est occup√©
function Test-PortInUse {
    param (
        [int]$Port
    )
    
    $connections = Get-NetTCPConnection -State Listen -ErrorAction SilentlyContinue | 
                  Where-Object { $_.LocalPort -eq $Port }
    
    return $connections -ne $null
}

# Fonction pour v√©rifier les d√©pendances Node.js
function Test-Dependencies {
    param(
        [string]$Path,
        [string]$ServiceName
    )
    
    Write-Message "V√©rification des d√©pendances pour $ServiceName..." "Info" "üîç"
    
    if (-not (Test-Path "$Path\node_modules")) {
        Write-Message "Les d√©pendances ne sont pas install√©es pour $ServiceName" "Warning" "‚ö†Ô∏è"
        $install = Read-Host "Voulez-vous installer les d√©pendances ? (O/n)"
        if ($install -eq "" -or $install -eq "O" -or $install -eq "o") {
            Push-Location $Path
            Write-Message "Installation des d√©pendances..." "Info" "üì¶"
            npm install
            Pop-Location
            Write-Message "D√©pendances install√©es avec succ√®s !" "Success" "‚úÖ"
        }
    } else {
        Write-Message "D√©pendances OK pour $ServiceName" "Success" "‚úÖ"
    }
}

# Fonction pour nettoyer les caches
function Clear-ProjectCache {
    Write-Message "Nettoyage des caches..." "Info" "üßπ"
    
    # Nettoyage frontend
    if (Test-Path "$frontendPath\node_modules\.vite") {
        Remove-Item -Recurse -Force "$frontendPath\node_modules\.vite"
        Write-Message "Cache Vite nettoy√©" "Success" "‚úÖ"
    }
    
    if (Test-Path "$frontendPath\dist") {
        Remove-Item -Recurse -Force "$frontendPath\dist"
        Write-Message "Dossier dist nettoy√©" "Success" "‚úÖ"
    }
    
    # Nettoyage backend
    if (Test-Path "$backendPath\dist") {
        Remove-Item -Recurse -Force "$backendPath\dist"
        Write-Message "Dossier dist backend nettoy√©" "Success" "‚úÖ"
    }
    
    Write-Message "Nettoyage termin√© !" "Success" "üéâ"
}

# Fonction pour d√©tecter PostgreSQL
function Test-PostgreSQL {
    # V√©rifier si pg_dump est disponible dans le PATH
    $pgDump = Get-Command pg_dump -ErrorAction SilentlyContinue
    if ($pgDump) {
        return @{
            Available = $true
            Path = $pgDump.Source
            Version = (pg_dump --version 2>&1 | Out-String).Trim()
        }
    }
    
    # Chercher dans les emplacements courants
    $commonPaths = @(
        "C:\Program Files\PostgreSQL\16\bin\pg_dump.exe",
        "C:\Program Files\PostgreSQL\15\bin\pg_dump.exe",
        "C:\Program Files\PostgreSQL\14\bin\pg_dump.exe",
        "C:\Program Files (x86)\PostgreSQL\16\bin\pg_dump.exe",
        "C:\Program Files (x86)\PostgreSQL\15\bin\pg_dump.exe"
    )
    
    foreach ($path in $commonPaths) {
        if (Test-Path $path) {
            # Ajouter temporairement au PATH
            $pgBinPath = Split-Path $path
            $env:Path = "$pgBinPath;$env:Path"
            
            return @{
                Available = $true
                Path = $path
                Version = (& $path --version 2>&1 | Out-String).Trim()
                AddedToPath = $true
            }
        }
    }
    
    return @{
        Available = $false
        Path = $null
        Version = $null
    }
}

# Fonction pour faire un backup JSON de la base de donn√©es avec Prisma
function Backup-DatabaseJSON {
    param(
        [string]$OutputPath
    )
    
    Write-Message "Export JSON de la base de donn√©es avec Prisma..." "Info" "üìä"
    
    Push-Location $backendPath
    
    try {
        # Cr√©er un script Node.js temporaire pour exporter les donn√©es
        $exportScript = @"
const { PrismaClient } = require('@prisma/client');
const fs = require('fs');

const prisma = new PrismaClient();

async function exportData() {
    try {
        const data = {
            users: await prisma.user.findMany({ include: { permissions: true } }),
            permissions: await prisma.permission.findMany(),
            exportDate: new Date().toISOString()
        };
        
        fs.writeFileSync('$($OutputPath -replace '\\', '\\')', JSON.stringify(data, null, 2), 'utf-8');
        console.log('Export JSON r√©ussi');
    } catch (error) {
        console.error('Erreur export:', error);
        process.exit(1);
    } finally {
        await prisma.`$disconnect();
    }
}

exportData();
"@
        
        # Cr√©er le script dans le dossier backend pour avoir acc√®s √† node_modules
        $tempScriptPath = Join-Path $backendPath "export-db-temp.js"
        $exportScript | Out-File -FilePath $tempScriptPath -Encoding utf8
        
        # Ex√©cuter le script depuis le dossier backend
        node $tempScriptPath
        
        Remove-Item $tempScriptPath -ErrorAction SilentlyContinue
        
        if (Test-Path $OutputPath) {
            $size = [Math]::Round((Get-Item $OutputPath).Length / 1KB, 2)
            Write-Message "Export JSON r√©ussi ! (${size} KB)" "Success" "‚úÖ"
            return $true
        }
    } catch {
        Write-Message "Erreur lors de l'export JSON : $_" "Error" "‚ùå"
        return $false
    } finally {
        Pop-Location
    }
    
    return $false
}

# Fonction pour afficher les logs des services
function Show-ServiceLogs {
    Write-Message "=== Logs des Services ===" "Info"
    Write-Host "1. Logs Backend" -ForegroundColor $Colors.Warning
    Write-Host "2. Logs Frontend" -ForegroundColor $Colors.Warning
    Write-Host "3. Logs Base de donn√©es" -ForegroundColor $Colors.Warning
    Write-Host "4. Retour au menu principal" -ForegroundColor $Colors.Muted
    Write-Message "========================" "Info"
    
    $logChoice = Read-Host "`nEntrez votre choix (1-4)"
    
    switch ($logChoice) {
        "1" {
            if (Test-Path "$backendPath\logs") {
                Get-ChildItem "$backendPath\logs" -Name | ForEach-Object {
                    Write-Host "üìÑ $_" -ForegroundColor $Colors.Info
                }
            } else {
                Write-Message "Aucun fichier de log trouv√© pour le backend" "Warning" "‚ö†Ô∏è"
            }
        }
        "2" {
            Write-Message "Les logs du frontend sont affich√©s dans la console de d√©veloppement" "Info" "‚ÑπÔ∏è"
        }
        "3" {
            # Afficher les derni√®res migrations
            if (Test-Path "$backendPath\prisma\migrations") {
                Write-Message "Derni√®res migrations :" "Info" "üìä"
                Get-ChildItem "$backendPath\prisma\migrations" -Directory | 
                Sort-Object CreationTime -Descending | 
                Select-Object -First 5 | 
                ForEach-Object {
                    Write-Host "  üìÅ $($_.Name)" -ForegroundColor $Colors.Info
                }
            }
        }
        "4" {
            return
        }
    }
    
    Read-Host "`nAppuyez sur Entr√©e pour continuer"
}

# Fonction pour arr√™ter un processus sur un port sp√©cifique
function Stop-ProcessOnPort {
    param (
        [int]$Port,
        [string]$ServiceName
    )
    
    Write-Message "Arr√™t de $ServiceName sur le port $Port..." "Warning" "üõë"
    $connections = Get-NetTCPConnection -State Listen -ErrorAction SilentlyContinue | 
                  Where-Object { $_.LocalPort -eq $Port }
    
    if ($connections) {
        foreach ($conn in $connections) {
            try {
                $owningProcess = $conn.OwningProcess
                if ($owningProcess) {
                    $process = Get-Process -Id $owningProcess -ErrorAction SilentlyContinue
                    
                    # Liste des processus syst√®me √† ignorer
                    $systemProcesses = @("Idle", "System", "Registry", "smss", "csrss", "wininit", "services", "lsass")
                    
                    # V√©rifier si ce n'est pas un processus syst√®me prot√©g√©
                    if ($process -and $process.Id -gt 4 -and $systemProcesses -notcontains $process.ProcessName) {
                        Write-Message "Arr√™t du processus $($process.ProcessName) (PID: $($process.Id))" "Warning" "‚èπÔ∏è"
                        try {
                            Stop-Process -Id $process.Id -Force -ErrorAction Stop
                            Write-Message "$ServiceName arr√™t√© avec succ√®s." "Success" "‚úÖ"
                        } catch {
                            Write-Message "Impossible d'arr√™ter le processus $($process.ProcessName) (PID: $($process.Id)): $($_.Exception.Message)" "Error" "‚ùå"
                        }
                    } else {
                        Write-Message "Processus syst√®me d√©tect√© ($($process.ProcessName), PID: $($process.Id)), ignor√©." "Secondary" "üîí"
                    }
                }
            } catch {
                Write-Message "Erreur lors de l'identification du processus: $($_.Exception.Message)" "Error" "‚ùå"
            }
        }
    }
    else {
        Write-Message "$ServiceName n'est pas en cours d'ex√©cution sur le port $Port." "Info" "‚ÑπÔ∏è"
    }
}

# Fonction pour d√©marrer le serveur backend
function Start-Backend {
    Write-Message "D√©marrage du serveur backend..." "Info" "üöÄ"
    
    # V√©rifier les d√©pendances
    Test-Dependencies -Path $backendPath -ServiceName "Backend"
    
    if (Test-PortInUse -Port $backendPort) {
        Write-Message "Le port $backendPort est d√©j√† utilis√©. Arr√™t du processus actuel..." "Warning" "‚ö†Ô∏è"
        Stop-ProcessOnPort -Port $backendPort -ServiceName "Backend"
        Start-Sleep -Seconds 2
    }
    
    Push-Location $backendPath
    Start-Process powershell -ArgumentList "-NoExit", "-Command", "cd '$backendPath'; npm run dev" -WindowStyle Normal
    Pop-Location
    
    Write-Message "Serveur backend d√©marr√© sur http://localhost:$backendPort" "Success" "üåê"
}

# Fonction pour d√©marrer le serveur frontend
function Start-Frontend {
    Write-Message "D√©marrage du serveur frontend..." "Info" "üöÄ"
    
    # V√©rifier les d√©pendances
    Test-Dependencies -Path $frontendPath -ServiceName "Frontend"
    
    if (Test-PortInUse -Port $frontendPort) {
        Write-Message "Le port $frontendPort est d√©j√† utilis√©. Arr√™t du processus actuel..." "Warning" "‚ö†Ô∏è"
        Stop-ProcessOnPort -Port $frontendPort -ServiceName "Frontend"
        Start-Sleep -Seconds 2
    }
    
    Push-Location $frontendPath
    Start-Process powershell -ArgumentList "-NoExit", "-Command", "cd '$frontendPath'; npm run dev" -WindowStyle Normal
    Pop-Location
    
    Write-Message "Serveur frontend d√©marr√© sur http://localhost:$frontendPort" "Success" "üåê"
}

# Fonction pour ouvrir le navigateur
function Open-Browser {
    param (
        [string]$Url = "http://localhost:$frontendPort"
    )
    
    Write-Message "Ouverture du navigateur..." "Info" "üåê"
    Start-Sleep -Seconds 5  # Attendre que le serveur soit pr√™t
    Start-Process $Url
    Write-Message "Navigateur ouvert sur $Url" "Success" "‚úÖ"
}

# Fonction pour d√©marrer Prisma Studio
function Start-DbStudio {
    Write-Message "D√©marrage de Prisma Studio..." "Info" "üöÄ"
    
    if (Test-PortInUse -Port $dbStudioPort) {
        Write-Message "Le port $dbStudioPort est d√©j√† utilis√©. Arr√™t du processus actuel..." "Warning" "‚ö†Ô∏è"
        Stop-ProcessOnPort -Port $dbStudioPort -ServiceName "Prisma Studio"
        Start-Sleep -Seconds 2
    }
    
    Push-Location $backendPath
    Start-Process powershell -ArgumentList "-NoExit", "-Command", "cd '$backendPath'; npx prisma studio" -WindowStyle Normal
    Pop-Location
    
    Write-Message "Prisma Studio d√©marr√© sur http://localhost:$dbStudioPort" "Success" "üåê"
}

# Fonction pour g√©rer la base de donn√©es
function Manage-Database {
    Write-Message "`n=== Gestion de la Base de Donn√©es ===" "Info"
    Write-Host "1. Appliquer les migrations" -ForegroundColor $Colors.Warning
    Write-Host "2. R√©initialiser la base de donn√©es" -ForegroundColor $Colors.Warning
    Write-Host "3. G√©n√©rer le client Prisma" -ForegroundColor $Colors.Warning
    Write-Host "4. Voir le statut des migrations" -ForegroundColor $Colors.Warning
    Write-Host "5. Cr√©er une nouvelle migration" -ForegroundColor $Colors.Warning
    Write-Host "6. Retour au menu principal" -ForegroundColor $Colors.Muted
    Write-Message "=================================" "Info"
    
    $dbChoice = Read-Host "`nEntrez votre choix (1-6)"
    
    switch ($dbChoice) {
        "1" {
            Push-Location $backendPath
            Write-Message "Application des migrations..." "Info" "üìä"
            npx prisma migrate deploy
            Write-Message "Migrations appliqu√©es !" "Success" "‚úÖ"
            Pop-Location
        }
        "2" {
            $confirm = Read-Host "‚ö†Ô∏è  √ätes-vous s√ªr de vouloir r√©initialiser la base de donn√©es ? (tapez 'OUI' pour confirmer)"
            if ($confirm -eq "OUI") {
                Push-Location $backendPath
                Write-Message "R√©initialisation de la base de donn√©es..." "Warning" "üîÑ"
                npx prisma migrate reset --force
                Write-Message "Base de donn√©es r√©initialis√©e !" "Success" "‚úÖ"
                Pop-Location
            }
        }
        "3" {
            Push-Location $backendPath
            Write-Message "G√©n√©ration du client Prisma..." "Info" "‚öôÔ∏è"
            npx prisma generate
            Write-Message "Client Prisma g√©n√©r√© !" "Success" "‚úÖ"
            Pop-Location
        }
        "4" {
            Push-Location $backendPath
            Write-Message "Statut des migrations :" "Info" "üìä"
            npx prisma migrate status
            Pop-Location
        }
        "5" {
            $migrationName = Read-Host "Nom de la migration"
            if ($migrationName) {
                Push-Location $backendPath
                Write-Message "Cr√©ation de la migration '$migrationName'..." "Info" "üìù"
                npx prisma migrate dev --name $migrationName
                Write-Message "Migration cr√©√©e !" "Success" "‚úÖ"
                Pop-Location
            }
        }
        "6" {
            return
        }
        default {
            Write-Message "Option invalide" "Error" "‚ùå"
        }
    }
    
    Read-Host "`nAppuyez sur Entr√©e pour continuer"
}

# Fonction pour g√©rer les ports
function Manage-Ports {
    Write-Message "`n=== Gestion des Ports ===" "Info"
    Write-Host "1. V√©rifier les ports utilis√©s" -ForegroundColor $Colors.Warning
    Write-Host "2. Lib√©rer un port sp√©cifique" -ForegroundColor $Colors.Warning
    Write-Host "3. Lib√©rer tous les ports de l'application" -ForegroundColor $Colors.Warning
    Write-Host "4. Retour au menu principal" -ForegroundColor $Colors.Muted
    Write-Message "=========================" "Info"
    
    $portChoice = Read-Host "`nEntrez votre choix (1-4)"
    
    switch ($portChoice) {
        "1" {
            Write-Message "`n√âtat des ports :" "Info" "üîç"
            
            $ports = @(
                @{Name="Backend"; Port=3000},
                @{Name="Frontend"; Port=3001},
                @{Name="Prisma Studio"; Port=5555}
            )
            
            foreach ($portInfo in $ports) {
                $isUsed = Test-PortInUse -Port $portInfo.Port
                if ($isUsed) {
                    $conn = Get-NetTCPConnection -State Listen -ErrorAction SilentlyContinue | 
                           Where-Object { $_.LocalPort -eq $portInfo.Port } | Select-Object -First 1
                    $process = Get-Process -Id $conn.OwningProcess -ErrorAction SilentlyContinue
                    Write-Message "$($portInfo.Name) ($($portInfo.Port)) : Utilis√© par $($process.ProcessName) (PID: $($process.Id))" "Error" "üî¥"
                } else {
                    Write-Message "$($portInfo.Name) ($($portInfo.Port)) : Libre" "Success" "üü¢"
                }
            }
        }
        "2" {
            $portToFree = Read-Host "Entrez le num√©ro du port √† lib√©rer"
            try {
                $portToFree = [int]$portToFree
                Stop-ProcessOnPort -Port $portToFree -ServiceName "Port $portToFree"
            } catch {
                Write-Message "Port invalide" "Error" "‚ùå"
            }
        }
        "3" {
            Write-Message "Lib√©ration de tous les ports de l'application..." "Warning" "üßπ"
            Stop-ProcessOnPort -Port 3000 -ServiceName "Backend"
            Stop-ProcessOnPort -Port 3001 -ServiceName "Frontend"
            Stop-ProcessOnPort -Port 5555 -ServiceName "Prisma Studio"
            Write-Message "Tous les ports ont √©t√© lib√©r√©s !" "Success" "‚úÖ"
        }
        "4" {
            return
        }
        default {
            Write-Message "Option invalide" "Error" "‚ùå"
        }
    }
    
    Read-Host "`nAppuyez sur Entr√©e pour continuer"
}

# Fonction pour g√©rer Git
function Manage-Git {
    Write-Message "`n=== Gestion Git ===" "Info"
    Write-Host "1. Statut Git (git status)" -ForegroundColor $Colors.Warning
    Write-Host "2. Voir les derniers commits (git log)" -ForegroundColor $Colors.Warning
    Write-Host "3. Cr√©er un commit (git add + commit)" -ForegroundColor $Colors.Warning
    Write-Host "4. Push vers GitHub (git push)" -ForegroundColor $Colors.Warning
    Write-Host "5. Pull depuis GitHub (git pull)" -ForegroundColor $Colors.Warning
    Write-Host "6. Voir les branches (git branch)" -ForegroundColor $Colors.Warning
    Write-Host "7. Cr√©er une nouvelle branche" -ForegroundColor $Colors.Warning
    Write-Host "8. Changer de branche (git checkout)" -ForegroundColor $Colors.Warning
    Write-Host "9. Diff√©rences (git diff)" -ForegroundColor $Colors.Warning
    Write-Host "10. Retour au menu principal" -ForegroundColor $Colors.Muted
    Write-Message "==================" "Info"
    
    $gitChoice = Read-Host "`nEntrez votre choix (1-10)"
    
    Push-Location $rootPath
    
    switch ($gitChoice) {
        "1" {
            Write-Message "Statut Git :" "Info" "üìä"
            git status
        }
        "2" {
            Write-Message "Derniers commits :" "Info" "üìù"
            git log --oneline -10 --decorate --graph
        }
        "3" {
            Write-Message "Fichiers modifi√©s :" "Info" "üìù"
            git status --short
            Write-Host ""
            $addAll = Read-Host "Ajouter tous les fichiers modifi√©s ? (O/n)"
            
            if ($addAll -eq "" -or $addAll -eq "O" -or $addAll -eq "o") {
                git add .
                Write-Message "Tous les fichiers ajout√©s" "Success" "‚úÖ"
            } else {
                $files = Read-Host "Entrez le(s) fichier(s) √† ajouter (s√©par√©s par des espaces)"
                if ($files) {
                    git add $files.Split(" ")
                    Write-Message "Fichiers ajout√©s" "Success" "‚úÖ"
                }
            }
            
            $commitMsg = Read-Host "Message du commit"
            if ($commitMsg) {
                git commit -m $commitMsg
                Write-Message "Commit cr√©√© avec succ√®s !" "Success" "‚úÖ"
            }
        }
        "4" {
            Write-Message "Push vers GitHub..." "Info" "üöÄ"
            $branch = git rev-parse --abbrev-ref HEAD
            Write-Message "Branche actuelle : $branch" "Info" "üåø"
            $confirm = Read-Host "Confirmer le push vers origin/$branch ? (O/n)"
            
            if ($confirm -eq "" -or $confirm -eq "O" -or $confirm -eq "o") {
                git push origin $branch
                Write-Message "Push effectu√© avec succ√®s !" "Success" "‚úÖ"
            }
        }
        "5" {
            Write-Message "Pull depuis GitHub..." "Info" "‚¨áÔ∏è"
            $branch = git rev-parse --abbrev-ref HEAD
            Write-Message "Branche actuelle : $branch" "Info" "üåø"
            git pull origin $branch
            Write-Message "Pull effectu√© avec succ√®s !" "Success" "‚úÖ"
        }
        "6" {
            Write-Message "Branches Git :" "Info" "üåø"
            git branch -a
        }
        "7" {
            $branchName = Read-Host "Nom de la nouvelle branche"
            if ($branchName) {
                git checkout -b $branchName
                Write-Message "Branche '$branchName' cr√©√©e et activ√©e !" "Success" "‚úÖ"
            }
        }
        "8" {
            Write-Message "Branches disponibles :" "Info" "üåø"
            git branch
            Write-Host ""
            $branchName = Read-Host "Nom de la branche √† activer"
            if ($branchName) {
                git checkout $branchName
                Write-Message "Branche '$branchName' activ√©e !" "Success" "‚úÖ"
            }
        }
        "9" {
            Write-Message "Diff√©rences (non commit√©es) :" "Info" "üìä"
            git diff
        }
        "10" {
            Pop-Location
            return
        }
        default {
            Write-Message "Option invalide" "Error" "‚ùå"
        }
    }
    
    Pop-Location
    Read-Host "`nAppuyez sur Entr√©e pour continuer"
}

# Fonction pour cr√©er un backup complet
function Create-Backup {
    Write-Message "`n=== Cr√©ation de Backup ===" "Info"
    
    # Cr√©er le dossier de backup s'il n'existe pas
    if (-not (Test-Path $backupPath)) {
        New-Item -ItemType Directory -Path $backupPath | Out-Null
        Write-Message "Dossier de backup cr√©√© : $backupPath" "Success" "üìÅ"
    }
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $backupName = "projet0_backup_$timestamp"
    $backupFolder = Join-Path $backupPath $backupName
    
    Write-Host "1. Backup complet (Application + Base de donn√©es)" -ForegroundColor $Colors.Warning
    Write-Host "2. Backup Application uniquement (ZIP)" -ForegroundColor $Colors.Warning
    Write-Host "3. Backup Base de donn√©es uniquement (SQL)" -ForegroundColor $Colors.Warning
    Write-Host "4. Retour au menu principal" -ForegroundColor $Colors.Muted
    Write-Message "==============================================" "Info"
    
    $backupChoice = Read-Host "`nEntrez votre choix (1-4)"
    
    switch ($backupChoice) {
        "1" {
            Write-Message "Cr√©ation d'un backup complet..." "Primary" "üíæ"
            
            # Cr√©er le dossier de backup
            New-Item -ItemType Directory -Path $backupFolder | Out-Null
            
            # 1. Backup de l'application (ZIP)
            Write-Message "Compression de l'application..." "Info" "üì¶"
            $appZipPath = Join-Path $backupFolder "application.zip"
            
            $excludePaths = @(
                "node_modules",
                "dist",
                ".vite",
                "logs",
                "backups",
                ".git"
            )
            
            # Utiliser 7zip si disponible, sinon Compress-Archive
            if (Get-Command 7z -ErrorAction SilentlyContinue) {
                $excludeArgs = $excludePaths | ForEach-Object { "-xr!$_" }
                & 7z a -tzip $appZipPath "$rootPath\*" $excludeArgs
            } else {
                # Fallback avec Compress-Archive (copie temporaire puis compression)
                Write-Message "Pr√©paration des fichiers √† compresser (ignorant node_modules, dist, etc.)..." "Info" "üîç"
                
                $tempFolder = Join-Path $env:TEMP "projet0_backup_temp_$(Get-Date -Format 'yyyyMMddHHmmss')"
                New-Item -ItemType Directory -Path $tempFolder -Force | Out-Null
                
                try {
                    # Fonction de copie r√©cursive avec exclusions
                    function Copy-WithExclusions {
                        param($Source, $Destination, $Excludes)
                        
                        # Copier les fichiers du dossier actuel
                        Get-ChildItem -Path $Source -File -ErrorAction SilentlyContinue | ForEach-Object {
                            Copy-Item -Path $_.FullName -Destination $Destination -Force
                        }
                        
                        # Copier les sous-dossiers (sauf ceux exclus)
                        Get-ChildItem -Path $Source -Directory -ErrorAction SilentlyContinue | ForEach-Object {
                            if ($Excludes -notcontains $_.Name) {
                                $destSubFolder = Join-Path $Destination $_.Name
                                New-Item -ItemType Directory -Path $destSubFolder -Force | Out-Null
                                Copy-WithExclusions -Source $_.FullName -Destination $destSubFolder -Excludes $Excludes
                            } else {
                                Write-Host "  ‚è≠Ô∏è  Ignor√© : $($_.Name)" -ForegroundColor DarkGray
                            }
                        }
                    }
                    
                    # Copier les fichiers en excluant les dossiers non d√©sir√©s
                    Copy-WithExclusions -Source $rootPath -Destination $tempFolder -Excludes $excludePaths
                    
                    Write-Message "Compression du dossier temporaire..." "Info" "üì¶"
                    Compress-Archive -Path "$tempFolder\*" -DestinationPath $appZipPath -CompressionLevel Optimal -Force
                    
                } finally {
                    # Nettoyer le dossier temporaire
                    if (Test-Path $tempFolder) {
                        Remove-Item -Path $tempFolder -Recurse -Force -ErrorAction SilentlyContinue
                    }
                }
            }
            Write-Message "Application compress√©e !" "Success" "‚úÖ"
            
            # 2. Backup de la base de donn√©es
            Write-Message "Export de la base de donn√©es..." "Info" "üóÑÔ∏è"
            
            # D√©tecter PostgreSQL
            $pgStatus = Test-PostgreSQL
            $sqlExportSuccess = $false
            $jsonExportSuccess = $false
            
            if ($pgStatus.Available) {
                Write-Message "PostgreSQL d√©tect√© : $($pgStatus.Version)" "Success" "‚úÖ"
                
                if ($pgStatus.AddedToPath) {
                    Write-Message "pg_dump ajout√© temporairement au PATH" "Info" "‚ÑπÔ∏è"
                }
                
                # Export SQL
                Push-Location $backendPath
                $dbSqlPath = Join-Path $backupFolder "database_dump.sql"
                $env:PGPASSWORD = "TOUFIK90"
                
                try {
                    pg_dump -h localhost -U postgres -d PROJECT_0 -f $dbSqlPath 2>$null
                    
                    if ((Test-Path $dbSqlPath) -and (Get-Item $dbSqlPath).Length -gt 0) {
                        $sqlSize = [Math]::Round((Get-Item $dbSqlPath).Length / 1KB, 2)
                        Write-Message "Base de donn√©es export√©e (SQL) ! (${sqlSize} KB)" "Success" "‚úÖ"
                        $sqlExportSuccess = $true
                    }
                } catch {
                    Write-Message "Erreur lors de l'export SQL : $_" "Error" "‚ùå"
                }
                
                Pop-Location
            } else {
                Write-Message "PostgreSQL non d√©tect√© dans le PATH" "Warning" "‚ö†Ô∏è"
                Write-Message "Utilisation du backup JSON alternatif..." "Info" "üí°"
            }
            
            # Export JSON alternatif (toujours effectu√© comme backup de secours)
            $dbJsonDataPath = Join-Path $backupFolder "database_data.json"
            $jsonExportSuccess = Backup-DatabaseJSON -OutputPath $dbJsonDataPath
            
            # Export sch√©ma Prisma
            Push-Location $backendPath
            $dbSchemaPath = Join-Path $backupFolder "database_schema.prisma"
            
            if (Test-Path "prisma\schema.prisma") {
                Copy-Item "prisma\schema.prisma" $dbSchemaPath
                Write-Message "Sch√©ma Prisma copi√© !" "Success" "‚úÖ"
            }
            
            Pop-Location
            
            # Afficher un r√©sum√© de l'export
            if ($sqlExportSuccess -and $jsonExportSuccess) {
                Write-Message "Backup base de donn√©es complet : SQL + JSON !" "Success" "üéâ"
            } elseif ($sqlExportSuccess) {
                Write-Message "Backup base de donn√©es : SQL uniquement" "Success" "‚úÖ"
            } elseif ($jsonExportSuccess) {
                Write-Message "Backup base de donn√©es : JSON uniquement (alternative)" "Warning" "‚ö†Ô∏è"
            } else {
                Write-Message "√âchec du backup de la base de donn√©es" "Error" "‚ùå"
            }
            
            # 3. Cr√©er un fichier d'information
            $infoPath = Join-Path $backupFolder "backup_info.txt"
            $backupInfo = @"
Projet-0 - Backup Complet
====================================
Date: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
Version: $timestamp

Contenu du backup:
- application.zip : Code source complet (sans node_modules, dist, .git)
- database_schema.prisma : Sch√©ma Prisma
"@
            
            if ($sqlExportSuccess) {
                $backupInfo += "`n- database_dump.sql : Export SQL complet de la base de donn√©es"
            }
            
            if ($jsonExportSuccess) {
                $backupInfo += "`n- database_data.json : Export JSON des donn√©es (toutes les tables)"
            }
            
            $backupInfo += @"

- backup_info.txt : Ce fichier

====================================
RESTAURATION
====================================

üì¶ √âtape 1 : Extraire l'application
--------------------------------------
1. D√©compresser application.zip dans un nouveau dossier
2. Ouvrir PowerShell/Terminal dans ce dossier

üìö √âtape 2 : Installer les d√©pendances
--------------------------------------
cd backend
npm install

cd ../frontend
npm install

üóÑÔ∏è √âtape 3 : Restaurer la base de donn√©es
--------------------------------------

"@

            if ($sqlExportSuccess) {
                $backupInfo += @"
M√âTHODE A : Restauration SQL (recommand√©e)
-------------------------------------------
# Cr√©er la base de donn√©es si elle n'existe pas
psql -U postgres -c "CREATE DATABASE PROJECT_0;"

# Restaurer les donn√©es
psql -U postgres -d PROJECT_0 -f database_dump.sql

# Appliquer les migrations
cd backend
npx prisma generate
npx prisma migrate deploy

"@
            }
            
            if ($jsonExportSuccess) {
                $backupInfo += @"
M√âTHODE B : Restauration JSON (alternative)
--------------------------------------------
# Si pg_dump n'est pas disponible, utilisez le fichier JSON

# 1. Cr√©er la structure de la base
cd backend
npx prisma migrate deploy

# 2. Cr√©er un script de restauration (restore-data.js) :
const { PrismaClient } = require('@prisma/client');
const fs = require('fs');
const prisma = new PrismaClient();

async function restoreData() {
    const data = JSON.parse(fs.readFileSync('path/to/database_data.json', 'utf-8'));
    
    // Restaurer dans l'ordre pour respecter les contraintes
    await prisma.permission.createMany({ data: data.permissions, skipDuplicates: true });
    await prisma.role.createMany({ data: data.roles, skipDuplicates: true });
    // ... continuer pour chaque table
    
    console.log('Restauration termin√©e');
    await prisma.`$disconnect();
}

restoreData();

# 3. Ex√©cuter le script
node restore-data.js

"@
            }
            
            $backupInfo += @"

‚öôÔ∏è √âtape 4 : Configuration
--------------------------------------
1. Copier les fichiers .env si n√©cessaire
2. V√©rifier la configuration de connexion PostgreSQL
3. Ajuster les ports si n√©cessaire

üöÄ √âtape 5 : D√©marrer l'application
--------------------------------------
cd backend
npm run dev

# Dans un autre terminal
cd frontend
npm run dev

====================================
NOTES IMPORTANTES
====================================
"@

            if (-not $sqlExportSuccess -and $jsonExportSuccess) {
                $backupInfo += @"

‚ö†Ô∏è  ATTENTION : Ce backup utilise le format JSON alternatif
   PostgreSQL n'√©tait pas disponible lors de la cr√©ation du backup.
   La restauration n√©cessitera l'√©criture d'un script Node.js personnalis√©.
   
   Recommandation : Installer PostgreSQL et refaire un backup SQL pour
   une restauration plus simple.

"@
            }
            
            $backupInfo += @"

üìä Statistiques du backup
- SQL disponible : $sqlExportSuccess
- JSON disponible : $jsonExportSuccess
- Sch√©ma Prisma : Oui

====================================
"@
            
            $backupInfo | Out-File -FilePath $infoPath -Encoding utf8
            
            # Compresser tout le dossier de backup
            $finalBackupZip = "$backupFolder.zip"
            Compress-Archive -Path $backupFolder -DestinationPath $finalBackupZip
            Remove-Item -Recurse -Force $backupFolder
            
            Write-Message "Backup complet cr√©√© avec succ√®s !" "Success" "üéâ"
            Write-Message "Emplacement : $finalBackupZip" "Success" "üìç"
            Write-Message "Taille : $([Math]::Round((Get-Item $finalBackupZip).Length / 1MB, 2)) MB" "Info" "üíæ"
        }
        "2" {
            Write-Message "Cr√©ation d'un backup de l'application..." "Primary" "üíæ"
            
            $appZipPath = Join-Path $backupPath "$backupName.zip"
            
            $excludePaths = @("node_modules", "dist", ".vite", "logs", "backups", ".git")
            
            Write-Message "Compression en cours (cela peut prendre quelques minutes)..." "Info" "üì¶"
            
            if (Get-Command 7z -ErrorAction SilentlyContinue) {
                $excludeArgs = $excludePaths | ForEach-Object { "-xr!$_" }
                & 7z a -tzip $appZipPath "$rootPath\*" $excludeArgs
            } else {
                # Fallback avec Compress-Archive (copie temporaire puis compression)
                Write-Message "Pr√©paration des fichiers √† compresser (ignorant node_modules, dist, etc.)..." "Info" "üîç"
                
                $tempFolder = Join-Path $env:TEMP "projet0_backup_temp_$(Get-Date -Format 'yyyyMMddHHmmss')"
                New-Item -ItemType Directory -Path $tempFolder -Force | Out-Null
                
                try {
                    # Fonction de copie r√©cursive avec exclusions
                    function Copy-WithExclusions {
                        param($Source, $Destination, $Excludes)
                        
                        # Copier les fichiers du dossier actuel
                        Get-ChildItem -Path $Source -File -ErrorAction SilentlyContinue | ForEach-Object {
                            Copy-Item -Path $_.FullName -Destination $Destination -Force
                        }
                        
                        # Copier les sous-dossiers (sauf ceux exclus)
                        Get-ChildItem -Path $Source -Directory -ErrorAction SilentlyContinue | ForEach-Object {
                            if ($Excludes -notcontains $_.Name) {
                                $destSubFolder = Join-Path $Destination $_.Name
                                New-Item -ItemType Directory -Path $destSubFolder -Force | Out-Null
                                Copy-WithExclusions -Source $_.FullName -Destination $destSubFolder -Excludes $Excludes
                            } else {
                                Write-Host "  ‚è≠Ô∏è  Ignor√© : $($_.Name)" -ForegroundColor DarkGray
                            }
                        }
                    }
                    
                    # Copier les fichiers en excluant les dossiers non d√©sir√©s
                    Copy-WithExclusions -Source $rootPath -Destination $tempFolder -Excludes $excludePaths
                    
                    Write-Message "Compression du dossier temporaire..." "Info" "üì¶"
                    Compress-Archive -Path "$tempFolder\*" -DestinationPath $appZipPath -CompressionLevel Optimal -Force
                    
                } finally {
                    # Nettoyer le dossier temporaire
                    if (Test-Path $tempFolder) {
                        Remove-Item -Path $tempFolder -Recurse -Force -ErrorAction SilentlyContinue
                    }
                }
            }
            
            Write-Message "Backup application cr√©√© avec succ√®s !" "Success" "üéâ"
            Write-Message "Emplacement : $appZipPath" "Success" "üìç"
            Write-Message "Taille : $([Math]::Round((Get-Item $appZipPath).Length / 1MB, 2)) MB" "Info" "üíæ"
        }
        "3" {
            Write-Message "Cr√©ation d'un backup de la base de donn√©es..." "Primary" "üíæ"
            
            Push-Location $backendPath
            
            # Export JSON (Prisma schema)
            $dbJsonPath = Join-Path $backupPath "$backupName`_schema.prisma"
            Copy-Item "prisma\schema.prisma" $dbJsonPath
            Write-Message "Sch√©ma Prisma export√© !" "Success" "‚úÖ"
            
            # Export SQL
            $dbSqlPath = Join-Path $backupPath "$backupName`_dump.sql"
            $env:PGPASSWORD = "TOUFIK90"
            
            Write-Message "Export SQL en cours..." "Info" "üóÑÔ∏è"
            pg_dump -h localhost -U postgres -d PROJECT_0 -f $dbSqlPath 2>$null
            
            if (Test-Path $dbSqlPath) {
                Write-Message "Backup base de donn√©es cr√©√© avec succ√®s !" "Success" "üéâ"
                Write-Message "Sch√©ma : $dbJsonPath" "Success" "üìç"
                Write-Message "Dump SQL : $dbSqlPath" "Success" "üìç"
                Write-Message "Taille : $([Math]::Round((Get-Item $dbSqlPath).Length / 1MB, 2)) MB" "Info" "üíæ"
            } else {
                Write-Message "Erreur lors de l'export SQL. V√©rifiez que PostgreSQL est install√© et accessible." "Error" "‚ùå"
            }
            
            Pop-Location
        }
        "4" {
            return
        }
        default {
            Write-Message "Option invalide" "Error" "‚ùå"
        }
    }
    
    Read-Host "`nAppuyez sur Entr√©e pour continuer"
}

# Fonction pour lister et restaurer les backups
function Restore-Backup {
    Write-Message "`n=== Restauration de Backup ===" "Info"
    
    if (-not (Test-Path $backupPath)) {
        Write-Message "Aucun dossier de backup trouv√©." "Warning" "‚ö†Ô∏è"
        Read-Host "Appuyez sur Entr√©e pour continuer"
        return
    }
    
    $backups = Get-ChildItem -Path $backupPath -Filter "projet0_backup_*.zip" | Sort-Object LastWriteTime -Descending
    
    if ($backups.Count -eq 0) {
        Write-Message "Aucun backup trouv√© dans $backupPath" "Warning" "‚ö†Ô∏è"
        Read-Host "Appuyez sur Entr√©e pour continuer"
        return
    }
    
    Write-Message "Backups disponibles :" "Info" "üì¶"
    for ($i = 0; $i -lt $backups.Count; $i++) {
        $backup = $backups[$i]
        $size = [Math]::Round($backup.Length / 1MB, 2)
        Write-Host "  $($i + 1). $($backup.Name) - ${size} MB - $(Get-Date $backup.LastWriteTime -Format 'yyyy-MM-dd HH:mm')" -ForegroundColor $Colors.Info
    }
    
    Write-Host "  0. Retour au menu principal" -ForegroundColor $Colors.Muted
    
    $choice = Read-Host "`nS√©lectionnez un backup √† restaurer (0-$($backups.Count))"
    
    if ($choice -eq "0") {
        return
    }
    
    try {
        $choiceNum = [int]$choice
        if ($choiceNum -lt 1 -or $choiceNum -gt $backups.Count) {
            Write-Message "Choix invalide" "Error" "‚ùå"
            return
        }
        
        $selectedBackup = $backups[$choiceNum - 1]
        
        Write-Message "‚ö†Ô∏è  ATTENTION : La restauration √©crasera les donn√©es actuelles !" "Warning" "‚ö†Ô∏è"
        $confirm = Read-Host "Tapez 'OUI' pour confirmer la restauration"
        
        if ($confirm -ne "OUI") {
            Write-Message "Restauration annul√©e." "Info" "‚ÑπÔ∏è"
            return
        }
        
        Write-Message "Restauration en cours..." "Primary" "üîÑ"
        
        # Extraire le backup dans un dossier temporaire
        $tempRestore = Join-Path $env:TEMP "projet0_restore_$(Get-Date -Format 'yyyyMMddHHmmss')"
        Expand-Archive -Path $selectedBackup.FullName -DestinationPath $tempRestore -Force
        
        Write-Message "Backup extrait. Consultez le fichier backup_info.txt pour les instructions de restauration." "Success" "‚úÖ"
        Write-Message "Emplacement : $tempRestore" "Info" "üìç"
        
        # Ouvrir l'explorateur
        Start-Process explorer.exe $tempRestore
        
    } catch {
        Write-Message "Erreur lors de la restauration : $_" "Error" "‚ùå"
    }
    
    Read-Host "`nAppuyez sur Entr√©e pour continuer"
}

# Fonction pour afficher le menu principal
function Show-Menu {
    Clear-Host
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor $Colors.Primary
    Write-Host "‚ïë             üöÄ Projet-0 Manager                 ‚ïë" -ForegroundColor $Colors.Primary
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor $Colors.Primary
    Write-Host
    Write-Host "üü¢ 1.  D√©marrer l'application (Backend + Frontend)" -ForegroundColor $Colors.Success
    Write-Host "üî¥ 2.  Arr√™ter l'application" -ForegroundColor $Colors.Error
    Write-Host "üîÑ 3.  Red√©marrer l'application" -ForegroundColor $Colors.Warning
    Write-Host "üóÑÔ∏è  4.  D√©marrer Prisma Studio (interface BDD)" -ForegroundColor $Colors.Secondary
    Write-Host "üåê 5.  G√©rer les ports" -ForegroundColor $Colors.Info
    Write-Host "üóÉÔ∏è  6.  G√©rer la base de donn√©es" -ForegroundColor $Colors.Secondary
    Write-Host "üßπ 7.  Nettoyer les caches" -ForegroundColor $Colors.Warning
    Write-Host "üìã 8.  Afficher les logs" -ForegroundColor $Colors.Info
    Write-Host "üåø 9.  Gestion Git (status, commit, push, pull)" -ForegroundColor $Colors.Success
    Write-Host "üíæ 10. Cr√©er un backup (ZIP + Database)" -ForegroundColor $Colors.Warning
    Write-Host "üì¶ 11. Restaurer un backup" -ForegroundColor $Colors.Info
    Write-Host "‚ùå 12. Quitter" -ForegroundColor $Colors.Muted
    Write-Host
    Write-Host "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -ForegroundColor $Colors.Primary
}

# Boucle principale du menu
do {
    Show-Menu
    $choice = Read-Host "Entrez votre choix (1-12)"
    
    switch ($choice) {
        "1" {
            Write-Message "D√©marrage de l'application compl√®te..." "Primary" "üöÄ"
            Start-Backend
            Start-Sleep -Seconds 3
            Start-Frontend
            Open-Browser
            Write-Message "Application d√©marr√©e avec succ√®s !" "Success" "üéâ"
            Write-Message "Backend: http://localhost:$backendPort" "Success" "üåê"
            Write-Message "Frontend: http://localhost:$frontendPort" "Success" "üåê"
            Read-Host "Appuyez sur Entr√©e pour continuer"
        }
        "2" {
            Write-Message "Arr√™t de l'application compl√®te..." "Primary" "üõë"
            Stop-ProcessOnPort -Port $backendPort -ServiceName "Backend"
            Stop-ProcessOnPort -Port $frontendPort -ServiceName "Frontend"
            Stop-ProcessOnPort -Port $dbStudioPort -ServiceName "Prisma Studio"
            Write-Message "Application arr√™t√©e avec succ√®s !" "Success" "‚úÖ"
            Read-Host "Appuyez sur Entr√©e pour continuer"
        }
        "3" {
            Write-Message "Red√©marrage de l'application compl√®te..." "Primary" "üîÑ"
            Stop-ProcessOnPort -Port $backendPort -ServiceName "Backend"
            Stop-ProcessOnPort -Port $frontendPort -ServiceName "Frontend"
            Start-Sleep -Seconds 3
            Start-Backend
            Start-Sleep -Seconds 3
            Start-Frontend
            Open-Browser
            Write-Message "Application red√©marr√©e avec succ√®s !" "Success" "üéâ"
            Write-Message "Backend: http://localhost:$backendPort" "Success" "üåê"
            Write-Message "Frontend: http://localhost:$frontendPort" "Success" "üåê"
            Read-Host "Appuyez sur Entr√©e pour continuer"
        }
        "4" {
            Start-DbStudio
            Write-Message "Prisma Studio d√©marr√© sur http://localhost:$dbStudioPort" "Success" "üåê"
            Read-Host "Appuyez sur Entr√©e pour continuer"
        }
        "5" {
            Manage-Ports
        }
        "6" {
            Manage-Database
        }
        "7" {
            Clear-ProjectCache
            Read-Host "Appuyez sur Entr√©e pour continuer"
        }
        "8" {
            Show-ServiceLogs
        }
        "9" {
            Manage-Git
        }
        "10" {
            Create-Backup
        }
        "11" {
            Restore-Backup
        }
        "12" {
            Write-Message "Au revoir ! üëã" "Info" "üéØ"
            exit
        }
        default {
            Write-Message "Option invalide. Veuillez choisir un num√©ro entre 1 et 12." "Error" "‚ùå"
            Start-Sleep -Seconds 2
        }
    }
} while ($true)
